name: Convert Domain Lists to Clash YAML (IP + V2Ray Support)

on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:

jobs:
  process-domains:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: üöÄ Checkout repository
        uses: actions/checkout@v4

      - name: üìÇ Create output directory
        run: mkdir -p output

      - name: üîç Process domain lists with bulletproof IP detection
        id: process_files
        run: |
          declare -A sources=(
            # ... (—Ç–µ –∂–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏) ...
          )
          
          file_list=""
          
          for url in "${!sources[@]}"; do
            custom_name="${sources[$url]}"
            safe_name=$(echo "$custom_name" | 
                        tr '[:upper:]' '[:lower:]' | 
                        sed 's/[^a-z0-9._-]/_/g' |
                        sed 's/__/_/g' |
                        sed 's/^_//;s/_$//')
            
            echo "üì• Processing $url ‚Üí $safe_name.yaml"
            
            curl -sfL "$url" | 
            # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
            tr -d '\r' |                      # –£–¥–∞–ª—è–µ–º Windows-—Å–∏–º–≤–æ–ª—ã \r
            sed -E 's/#.*$//g' |              # –£–¥–∞–ª—è–µ–º –í–°–ï –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –¥–æ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–æ–∫–∏
            sed -E 's/^[ \t]*//; s/[ \t]*$//' | # –¢–æ—á–Ω–∞—è –æ–±—Ä–µ–∑–∫–∞ –ø—Ä–æ–±–µ–ª–æ–≤
            grep -vE '^$|://' |               # –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ URL
            awk -v name="$safe_name" '
              BEGIN { print "payload:" }
              
              {
                # –ü–æ–ª–Ω–∞—è –æ–±—Ä–µ–∑–∫–∞ whitespace
                gsub(/^[ \t]+|[ \t]+$/, "", $0);
                if ($0 == "") next;
                
                # 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ IP –ü–ï–†–ï–î –¥–æ–º–µ–Ω–∞–º–∏ (–≥–ª–∞–≤–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
                if ($0 ~ /^([0-9]{1,3}\.){3}[0-9]{1,3}(\/[0-9]{1,2})?$/) {
                  split($0, parts, "/");
                  ip = parts[1];
                  
                  # –í–∞–ª–∏–¥–∞—Ü–∏—è IPv4
                  split(ip, octets, ".");
                  valid = 1;
                  if (length(octets) != 4) valid = 0;
                  else {
                    for (i=1; i<=4; i++) {
                      if (octets[i] !~ /^[0-9]+$/ || octets[i] < 0 || octets[i] > 255) {
                        valid = 0;
                        break;
                      }
                    }
                  }
                  
                  if (valid) {
                    # CIDR –∏–ª–∏ /32 –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ IP
                    if (length(parts) == 2) {
                      prefix = parts[2] + 0;
                      if (prefix >= 0 && prefix <= 32) {
                        print "  - IP-CIDR," $0;
                        next;
                      }
                    } else {
                      print "  - IP-CIDR," ip "/32";
                      next;
                    }
                  }
                }
                
                # 2. –û–±—Ä–∞–±–æ—Ç–∫–∞ IPv6
                else if ($0 ~ /^[0-9a-fA-F:]+(\/[0-9]{1,3})?$/) {
                  split($0, parts, "/");
                  ip = parts[1];
                  
                  # –ü—Ä–æ—Å—Ç–∞—è, –Ω–æ –Ω–∞–¥–µ–∂–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è IPv6
                  if (ip ~ /:/ && ip !~ /\.\./ && ip != "::" && ip != ":") {
                    colons = gsub(/:/, "", ip);  # –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–≤–æ–µ—Ç–æ—á–∏–π
                    if (colons >= 1 && colons <= 7) {  # –í–∞–ª–∏–¥–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è IPv6
                      if (length(parts) == 2) {
                        prefix = parts[2] + 0;
                        if (prefix >= 0 && prefix <= 128) {
                          print "  - IP-CIDR6," $0;
                          next;
                        }
                      } else {
                        print "  - IP-CIDR6," ip "/128";
                        next;
                      }
                    }
                  }
                }
                
                # 3. –û–±—Ä–∞–±–æ—Ç–∫–∞ V2Ray-–ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
                if ($0 ~ /^domain:/) {
                  domain = substr($0, 8);
                  gsub(/^[ \t]+|[ \t]+$/, "", domain);
                  processDomain(domain);
                  next;
                }
                else if ($0 ~ /^full:/) {
                  domain = substr($0, 6);
                  gsub(/^[ \t]+|[ \t]+$/, "", domain);
                  print "  - DOMAIN," domain;
                  next;
                }
                else if ($0 ~ /^regexp:/) {
                  regex = substr($0, 9);
                  gsub(/^[ \t]+|[ \t]+$/, "", regex);
                  gsub(/\\/, "\\\\", regex);
                  print "  - DOMAIN-REGEX," regex;
                  next;
                }
                else if ($0 ~ /^geosite:/) {
                  next;
                }
                
                # 4. –ü–æ—Å–ª–µ–¥–Ω—è—è –Ω–∞–¥–µ–∂–¥–∞: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–∫ –¥–æ–º–µ–Ω–∞
                processDomain($0);
              }
              
              function processDomain(domain) {
                gsub(/^[ \t]+|[ \t]+$/, "", domain);
                if (domain == "") return;
                
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ wildcard-–¥–æ–º–µ–Ω–æ–≤
                if (domain ~ /^\*\./) {
                  gsub(/^\*\./, "", domain);
                  print "  - DOMAIN-SUFFIX," domain;
                }
                else if (domain ~ /\*$/) {
                  gsub(/\*$/, "", domain);
                  print "  - DOMAIN-KEYWORD," domain;
                }
                else {
                  print "  - DOMAIN-SUFFIX," domain;
                }
              }
            ' > "output/${safe_name}.yaml"
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è
            if [ ! -s "output/${safe_name}.yaml" ]; then
              echo "‚ùå EMPTY FILE: $safe_name.yaml from $url"
              exit 1
            fi
            
            rules_count=$(grep -c '^  - ' "output/${safe_name}.yaml")
            echo "‚úÖ Created $safe_name.yaml ($rules_count rules)"
            
            file_size=$(numfmt --to=iec-i --suffix=B --format="%.1f" $(stat -c%s "output/${safe_name}.yaml") 2>/dev/null || echo "unknown size")
            file_list+="- $safe_name.yaml ($file_size, $rules_count rules)\n"
          done
          
          echo "files_list<<EOF" >> $GITHUB_ENV
          echo -e "$file_list" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: üè∑Ô∏è Generate release tag
        run: echo "RELEASE_TAG=v$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV

      - name: üì§ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "Clash Rules with IP Support"
          body: |
            **Generated files (with IP/CIDR support):**
            ${{ env.files_list }}
          files: output/*.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üóëÔ∏è Cleanup
        if: always()
        run: rm -rf output/
